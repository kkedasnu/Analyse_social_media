# Analyse_social_media
Анализ данных и социальные медиа(ИПМКН.М. 1курс 2 семестр)

# Задание лабораторной №1: 

Требуется написать скрипт на языке Python с реализацией алгоритма Дейкстры для заданного графа. Граф задаётся матрицей смежности или списком смежных вершин. Алгоритм должен находить кратчайшие пути от произвольной начальной вершины до всех остальных. Для представления графов разрешается использовать сторонние библиотеки, но не разрешается использовать реализацию алгоритма Дейкстры в составе сторонних библиотек.

# Задание лабораторной №2:
С использованием библиотеки NetworkX требуется написать скрипт для вычисления меры центральности в собственных векторах для некоторого графа. Преподавателем будет предоставлена некоторая характеристика мер центральности вершин несложного графа, и требуется подобрать (вручную, не нужно автоматизировать) исходный граф, в которой меры центральности удовлетворяют заданным характеристикам.

личные параметры: **Требуется получить центральность для 21 узлов с «ямой» и «горбиком» значений, т. е. когда последовательность сначала падает вниз, потом возрастает до пикового значения, а затем снова опускается.**

# Задание лабораторной №3: 
С использованием библиотеки NetworkX требуется написать скрипт для генерации графа в модели Эрдёша-Реньи с заданными характеристиками. Преподавателем будут даны значения количества вершин и вероятность появления случайного ребра. Требуется вычислить в программе среднюю степень вершины и сравнить её со значением средней степени вершины, полученной по формуле из материала лекций.

личные параметры: **n=25, p=0,35**

Решения: 
lab1. 
1. Инициализация
R = {start}  # Множество обработанных вершин (R)
Q = set()    # Множество кандидатов (Q)
distances = {node: float('inf') for node in graph}
distances[start] = 0
prev = {node: None for node in graph}  # Для восстановления пути
2. Шаг 1: Заполнение множества Q смежными вершинами начальной вершины
for neighbor, weight in graph[start]:
    Q.add(neighbor)
    distances[neighbor] = weight
    prev[neighbor] = start
3. Основной цикл: Обработка вершин из Q
while Q:
    # Шаг 2: Выбор вершины с минимальным расстоянием
    u = min(Q, key=lambda node: distances[node])
    Q.remove(u)
    R.add(u)  # Переносим u из Q в R

4. Шаг 3: Обработка соседей вершины u
for v, weight in graph[u]:
    if v in R:
        continue  # Пропускаем уже обработанные вершины
    if v not in Q:
        Q.add(v)  # Добавляем новую вершину в Q
    # Обновление расстояния до v
    if distances[u] + weight < distances[v]:
        distances[v] = distances[u] + weight
        prev[v] = u
5. Возвращаем результат
return distances, prev
distances — кратчайшие расстояния от start до всех вершин.
prev — словарь для восстановления путей.
6. Пример использования
if __name__ == "__main__":
    graph = {
        'A': [('B', 4), ('C', 2)],
        'B': [('A', 4), ('C', 5), ('D', 10)],
        'C': [('A', 2), ('B', 5), ('D', 3)],
        'D': [('B', 10), ('C', 3)]
    }
    start_node = 'A'
    distances, prev = deikstry(graph, start_node)

    print(f"Кратчайшие расстояния от вершины {start_node}:")
    for node, dist in distances.items():
        print(f"  До {node}: {dist}")
        path = []
        current = node
        while current:
            path.append(current)
            current = prev[current]
        path.reverse()
        print(f"    Путь: {' -> '.join(path)}")

Создаем граф в виде словаря: ключ — вершина, значение — список пар (сосед, вес).
Вызываем функцию deikstry с начальной вершиной A.
Выводим расстояния и пути для каждой вершины.
Пример вывода:
Кратчайшие расстояния от вершины A:
  До A: 0
    Путь: A
  До B: 4
    Путь: A -> B
  До C: 2
    Путь: A -> C
  До D: 5
    Путь: A -> C -> D

